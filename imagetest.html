<!DOCTYPE HTML>
<html>
<head>		
	<style>
		body {
			background-color: #000000;
			color: #ffffff;
			text-align: center;
		}
		.alice {
			font-family: "Courier New", monospace;
			font-size: 12px;
		}
		.uiBox {
			font-family: "Courier New", monospace;
			font-size: 12px;
			margin: 0;
			position: relative;
			top: -6em;
		}
		.lenny {
			font-family: Arial;
			font-size: 2em;
		}
		.opaque {
			background-color: #000000;
		}
	</style>
	<script type="text/javascript">
	ramp = '       .........,,,,,,,:::::::;;;;;;;;rrrrrrriiiiiiiii7777777XXXXXXXXXXXSSSSSSS2222222aaaaaaZZZZZZZZZZ888888800000000BBBBBBBBWWWWWWWWW@@@@@@@MMMMMMM';

	ansiColors = [[170, 0, 0],[0,170,0],[170,85,0],[0,0,170],[170,0,170],[0,170,170],[85,85,85],[255,85,85],[85,255,85],[255,255,85],[85,85,255],[255,85,255],[85,255,255],[255,255,255]];
	
	ansiNoGray = [[170, 0, 0],[0,170,0],[170,85,0],[0,0,170],[170,0,170],[0,170,170],[255,85,85],[85,255,85],[255,255,85],[85,85,255],[255,85,255],[85,255,255],[255,255,255]];

	ansiNoWhite = [[170, 0, 0],[0,170,0],[170,85,0],[0,0,170],[170,0,170],[0,170,170],[255,85,85],[85,255,85],[255,255,85],[85,85,255],[255,85,255],[85,255,255]];

	testPalette = [[150, 0, 0],[0,0,150]];

	rgbPalette = [[170, 0,0],[0,170,0],[0,0,170]];

	function euclidianDistance(a1,a2,a3,b1,b2,b3) {
		return Math.sqrt(Math.pow((a1-b1),2) + Math.pow((a2-b2),2) + Math.pow((a3-b3),2));
	}

	function paddedHexString(int) {
		var hexString = int.toString(16);
		return ("00" + hexString).substring(hexString.length, hexString.length + 2);
	}
	
	function rgbDistance(r1,g1,b1,r2,g2,b2) {
		return euclidianDistance(r1,g1,b1,r2,g2,b2);
	}
	
	function uvDistance(r1,g1,b1,r2,g2,b2) {
		var u1 = (-0.147*r1) + (-0.289*g1) + (0.436*b1);
		var v1 = (0.615*r1) + (-0.515*g1) + (-0.1*b1);
		var u2 = (-0.147*r2) + (-0.289*g2) + (0.436*b2);
		var v2 = (0.615*r2) + (-0.515*g2) + (-0.1*b2);
		return euclidianDistance(u1,v1,0,u2,v2,0);
	}
		
	function selectColor(red, green, blue, colorArray, distanceFunction) {
		var minDistance = 512;
		var minIndex = 0;
		for (var i in colorArray) {
			var color = colorArray[i];
			var distance = distanceFunction(red,green,blue,color[0],color[1],color[2]);
			if (distance <= minDistance) {
				minDistance = distance;
				minIndex = i;
			}
		}
		return minIndex;
	}

	function selectCharacter(ramp, intensity) {
		var index = Math.round((intensity / 255) * (ramp.length - 1));
		return ramp[index];
	}

	function generateColorCode(r, g, b) {
		return "#" + paddedHexString(r) + paddedHexString (g) + paddedHexString(b);
	}

	function checkByteArray(byteArray) {
		if (byteArray[0] != 0x52 || byteArray[1] != 0x47 || byteArray[2] != 0x42 || byteArray[3] != 0x41) {
			alert('invalid RGBA byteArray');
			return false;
		var width = byteArray[4];
		var height = byteArray[5];
		var expectedSize = (width * height * 4) + 6;
		if (byteArray.length != expectedSize)
			alert('expected byteArray of size ' + expectedSize + ', got size ' + byteArray.length);
		}
		return true;
	}

	function generateCharacterSpan(red, green, blue, ramp, colorArray, distanceFunction) {
		var returnSpan = document.createElement('span');
		var intensity = Math.round((red + blue + green) / 3);
		returnSpan.innerText = selectCharacter(ramp, intensity);
		var color = colorArray[selectColor(red, green, blue, colorArray, distanceFunction)];
		var colorCode = generateColorCode(color[0], color[1], color[2]);
		//var colorCode = "#ffffff";
		returnSpan.setAttribute('style', 'color: ' + colorCode);
		return returnSpan;
	}

	function renderCanvas(byteArray, canvasID, ramp, palette, distanceFunction) {
		if (!checkByteArray(byteArray)) return false;
		console.time('render');
		// header check
		var width = byteArray[4];
		var height = byteArray[5];
		var returnPre = document.createElement('pre');
		console.time('lel');
		for (var i = 0; i < height; i++) {
			var lineOffset = (i * (width * 4)) + 6;
			for (var j = 0; j < width; j++) {
				var offset = lineOffset + (j * 4);
				var characterSpan = generateCharacterSpan(byteArray[offset], byteArray[offset + 1], byteArray[offset + 2], ramp, palette, distanceFunction);
				returnPre.appendChild(characterSpan);
			}
			returnPre.appendChild(document.createTextNode("\n"));
		}
		console.timeEnd('lel');
		var oldCanvas = document.getElementById(canvasID).firstChild;
		document.getElementById(canvasID).replaceChild(returnPre, oldCanvas);
		console.timeEnd('render');
	}

	// function altGenerateCharacterSpan(red, green, blue, ramp, colorArray, distanceFunction) {
	// 	var color = colorArray[selectColor(red, green, blue, colorArray, distanceFunction)];
	// 	array.push([selectCharacter(ramp, Math.round((red + blue + green) / 3)), generateColorCode(color[0], color[1], color[2])]);
	// }

	// function altRenderCanvas(byteArray, canvasID, ramp, palette, distanceFunction) {
	// 	if (!checkByteArray(byteArray)) return false;
	// 	console.time('altRender');
	// 	array = new Array();
	// 	var width = byteArray[4];
	// 	var height = byteArray[5];
	// 	console.time('lel');
	// 	for (var i = 0; i < height; i++) {
	// 		var lineOffset = (i * (width * 4)) + 6;
	// 		for (var j = 0; j < width; j++) {
	// 			var offset = lineOffset + (j * 4);
	// 			altGenerateCharacterSpan(byteArray[offset], byteArray[offset + 1], byteArray[offset + 2], ramp, palette, distanceFunction);
	// 		}
	// 		array.push(['\n', '#000000']);
	// 	}
	// 	console.timeEnd('lel');
	// 	var thing = document.getElementById(canvasID);
	// 	var newThing = document.createElement('pre');
	// 	for(i in array) {
	// 		var shit = document.createElement('span');
	// 		shit.setAttribute('style', 'color: ' + i[1]);
	// 		shit.innerText = i[0];
	// 		newThing.appendChild(shit);
	// 	}
	// 	document.replaceChild(newThing,thing.children[0]);
	// 	console.timeEnd('altRender');
	// }

	function generateSaveImage(imageName, imagesObject, callback) {
		if(typeof(callback)==='undefined') callback = function(){};
		return function() {
			var arrayBuffer = this.response;
			if (arrayBuffer) {
				imagesObject[imageName] = new Uint8Array(arrayBuffer);
				callback();
			}
		}
	}

	function loadImage(url, imageObject, callback) {
		var req = new XMLHttpRequest();
		req.open("GET", "rendered/"+url+".rgba", true);
		console.log('fuck');
		req.responseType = "arraybuffer";

		req.onload = generateSaveImage(url, imageObject, callback);

		req.send();
	}

	function compositePoint(r1, g1, b1, r2, g2, b2, a2) {
		alpha = a2 / 255;
		return [Math.round((r1 * (1 - alpha)) + (r2 * alpha)),
				Math.round((g1 * (1 - alpha)) + (g2 * alpha)),
				Math.round((b1 * (1 - alpha)) + (b2 * alpha))];
	}

	function compositeImages(background, foreground, xOffset, yOffset) {
		//if(!checkByteArray(background) || !checkByteArray(foreground)) return false;
		console.time("composite");
		var bWidth = background[4];
		var bHeight = background[5];
		var fWidth = foreground[4];
		var fHeight = foreground[5];
		returnArray = new Uint8Array(background);
		for(var i = 0; i < fHeight; i++) {
			if (yOffset + i >= bHeight) break;
			var fLineOffset = (i * fWidth * 4) + 6;
			var bLineOffset = ((i + yOffset) * bWidth * 4) + 6;
			for(var j = 0; j < fWidth; j++) {
				if((xOffset + j) >= bWidth) break;
				var fOffset = fLineOffset + (4 * j);
				var bOffset = bLineOffset + (4 * (j + xOffset));
				var point = compositePoint(background[bOffset], background[bOffset + 1], background[bOffset + 2],
					foreground[fOffset], foreground[fOffset + 1], foreground[fOffset + 2], foreground[fOffset + 3]);
				for(var k = 0; k < 3; k++) {
					returnArray[bOffset + k] = point[k];
				}
			}
		}
		console.timeEnd("composite");
		return returnArray;
	}

	function lel() {
		var begin = performance.now();
		renderCanvas(test['ko.png'], 'alice', ramp, ansiNoGray, rgbDistance);
		var end = performance.now();
		window.alert("Rendered in " + (end - begin).toFixed(2) + " ms");
	}

	function kek() {
		altRenderCanvas(test['ko.png'], 'alice', ramp, ansiNoGray, rgbDistance);

	}

	function comp() {
		shit = compositeImages(test['ko.png'], test['m.png'], 39, 80);
		renderCanvas(shit, 'alice', ramp, ansiColors, rgbDistance);
	}

	test = {};
	loadImage('ko.png', test, lel);
	loadImage('m.png', test);
	</script>
</head>
<body>
	<div id="alice">
		<pre></pre>
	</div>
</body>
</html>
