<!DOCTYPE HTML>
<html>
<head>		
	<style>
		body {
			background-color: #000000;
			color: #ffffff;
			text-align: center;
		}
		.alice {
			font-family: "Courier New", monospace;
			font-size: 12px;
		}
		.uiBox {
			font-family: "Courier New", monospace;
			font-size: 12px;
			margin: 0;
			position: relative;
			top: -6em;
		}
		.lenny {
			font-family: Arial;
			font-size: 2em;
		}
		.opaque {
			background-color: #000000;
		}
	</style>
	<script type="text/javascript">
	ramp = '       .........,,,,,,,:::::::;;;;;;;;rrrrrrriiiiiiiii7777777XXXXXXXXXXXSSSSSSS2222222aaaaaaZZZZZZZZZZ888888800000000BBBBBBBBWWWWWWWWW@@@@@@@MMMMMMM';

	ansiColors = [[170, 0, 0],[0,170,0],[170,85,0],[0,0,170],[170,0,170],[0,170,170],[85,85,85],[255,85,85],[85,255,85],[255,255,85],[85,85,255],[255,85,255],[85,255,255],[255,255,255]];
	
	ansiNoGray = [[170, 0, 0],[0,170,0],[170,85,0],[0,0,170],[170,0,170],[0,170,170],[255,85,85],[85,255,85],[255,255,85],[85,85,255],[255,85,255],[85,255,255],[255,255,255]];

	ansiNoWhite = [[170, 0, 0],[0,170,0],[170,85,0],[0,0,170],[170,0,170],[0,170,170],[255,85,85],[85,255,85],[255,255,85],[85,85,255],[255,85,255],[85,255,255]];

	testPalette = [[150, 0, 0],[0,0,150]];

	rgbPalette = [[170, 0,0],[0,170,0],[0,0,170]];

	function euclidianDistance(a1,a2,a3,b1,b2,b3) {
		return Math.sqrt(Math.pow((a1-b1),2) + Math.pow((a2-b2),2) + Math.pow((a3-b3),2));
	}

	function paddedHexString(int) {
		var hexString = int.toString(16);
		return ("00" + hexString).substring(hexString.length, hexString.length + 2);
	}
	
	function rgbDistance(r1,g1,b1,r2,g2,b2) {
		return euclidianDistance(r1,g1,b1,r2,g2,b2);
	}
	
	function uvDistance(r1,g1,b1,r2,g2,b2) {
		var u1 = (-0.147*r1) + (-0.289*g1) + (0.436*b1);
		var v1 = (0.615*r1) + (-0.515*g1) + (-0.1*b1);
		var u2 = (-0.147*r2) + (-0.289*g2) + (0.436*b2);
		var v2 = (0.615*r2) + (-0.515*g2) + (-0.1*b2);
		return euclidianDistance(u1,v1,0,u2,v2,0);
	}
		
	function selectColor(red, green, blue, colorArray, distanceFunction) {
		var minDistance = 512;
		var minIndex = 0;
		for (var i in colorArray) {
			var color = colorArray[i];
			var distance = distanceFunction(red,green,blue,color[0],color[1],color[2]);
			if (distance <= minDistance) {
				minDistance = distance;
				minIndex = i;
			}
		}
		return minIndex;
	}

	function selectCharacter(ramp, intensity) {
		var index = Math.round((intensity / 255) * (ramp.length - 1));
		return ramp[index];
	}

	function generateColorCode(r, g, b) {
		return "#" + paddedHexString(r) + paddedHexString (g) + paddedHexString(b);
	}

	function generateCharacterSpan(red, green, blue, ramp, colorArray, distanceFunction) {
		var returnSpan = document.createElement('span');
		var intensity = Math.round((red + blue + green) / 3);
		returnSpan.innerText = selectCharacter(ramp, intensity);
		var color = colorArray[selectColor(red, green, blue, colorArray, distanceFunction)];
		var colorCode = generateColorCode(color[0], color[1], color[2]);
		//var colorCode = "#ffffff";
		returnSpan.setAttribute('style', 'color: ' + colorCode);
		return returnSpan;
	}

	function renderCanvas(byteArray, canvasID, ramp, palette, distanceFunction) {
		console.time('render');
		// header check
		if (byteArray[0] != 0x52 || byteArray[1] != 0x47 || byteArray[2] != 0x42 || byteArray[3] != 0x41) {
			alert('invalid RGBA byteArray');
			return false;
		}
		var width = byteArray[4];
		var height = byteArray[5];
		var expectedSize = (width * height * 4) + 6
		if (byteArray.length != expectedSize)
			alert('expected byteArray of size ' + expectedSize + ', got size ' + byteArray.length);
		var returnPre = document.createElement('pre');
		console.time('lel');
		for (var i = 0; i < height; i++) {
			var lineOffset = (i * (width * 4)) + 6;
			for (var j = 0; j < width; j++) {
				var offset = lineOffset + (j * 4);
				var characterSpan = generateCharacterSpan(byteArray[offset], byteArray[offset + 1], byteArray[offset + 2], ramp, palette, distanceFunction);
				returnPre.appendChild(characterSpan);
			}
			returnPre.appendChild(document.createTextNode("\n"));
		}
		console.timeEnd('lel');
		var oldCanvas = document.getElementById(canvasID).firstChild;
		document.getElementById(canvasID).replaceChild(returnPre, oldCanvas);
		console.timeEnd('render');
	}

	function generateSaveImage(imageName, imagesObject) {
		return function() {
			var arrayBuffer = this.response;
			if (arrayBuffer) {
				imagesObject[imageName] = new Uint8Array(arrayBuffer);
			}
		}
	}

	function loadImage(url, imageObject) {
		var req = new XMLHttpRequest();
		req.open("GET", "rendered/"+url+".rgba", true);
		console.log('fuck');
		req.responseType = "arraybuffer";

		req.onload = generateSaveImage(url, imageObject);

		req.send();
	}

	test = {};
	loadImage('ko.png', test);
	function lel() {
		renderCanvas(test['ko.png'], 'alice', ramp, ansiNoGray, rgbDistance);
	}

	</script>
</head>
<body>
	<div id="alice">
		<pre></pre>
	</div>
</body>
</html>
